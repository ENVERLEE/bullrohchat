import os
import json
import oracledb
import numpy as np
oracledb.init_oracle_client()
print(f"DEBUG: oracledb module loaded from: {oracledb.__file__}")
print(f"DEBUG: oracledb version: {oracledb.__version__}")
from typing import List, Dict, Any, Tuple, Optional

class OracleManager:
    def __init__(self):
        try:
            self.user = os.getenv("ORACLE_USER")
            self.password = os.getenv("ORACLE_PASSWORD")
            self.dsn = os.getenv("ORACLE_ATP_DSN")
            self.wallet_path = os.getenv("ORACLE_WALLET_PATH")
            self.wallet_password = os.getenv("ORACLE_WALLET_PASSWORD")

            if not all([self.user, self.password, self.dsn, self.wallet_path, self.wallet_password]):
                raise ValueError(".env íŒŒì¼ì— Oracle Cloud ATP ì ‘ì† ì •ë³´ê°€ ëª¨ë‘ ì„¤ì •ë˜ì—ˆëŠ”ì§€ í™•ì¸í•´ì£¼ì„¸ìš”.")

            self.pool = oracledb.create_pool(
                user=self.user, password=self.password, dsn=self.dsn,
                config_dir=self.wallet_path, wallet_location=self.wallet_path,
                wallet_password=self.wallet_password, min=2, max=5, increment=1
            )
            print("âœ… Oracle Cloud ATP ì—°ê²° í’€ ìƒì„± ì™„ë£Œ.")

            self.embedding_dim = 1536 # ì„ë² ë”© ë²¡í„° ì°¨ì› (OpenAI text-embedding-ada-002 ê¸°ì¤€)

        except oracledb.Error as e:
            print(f"âŒ Oracle DB ì—°ê²° í’€ ìƒì„± ì‹¤íŒ¨: {e}")
            raise

    def _get_connection(self):
        return self.pool.acquire()

    def _execute_sql(self, sql: str, params: dict = None, commit: bool = False):
        with self.pool.acquire() as connection:
            with connection.cursor() as cursor:
                cursor.execute(sql, params or {})
                if commit:
                    connection.commit()
                else:
                    try: 
                        rows = cursor.fetchall()
                        # LOB ê°ì²´ë¥¼ ë¬¸ìì—´ë¡œ ë³€í™˜
                        processed_rows = []
                        for row in rows:
                            processed_row = []
                            for item in row:
                                if isinstance(item, oracledb.LOB):
                                    processed_row.append(item.read())
                                else:
                                    processed_row.append(item)
                            processed_rows.append(tuple(processed_row))
                        return processed_rows
                    except oracledb.Error: return None

    def _execute_many(self, sql: str, params_list: List[Dict]):
        with self.pool.acquire() as connection:
            with connection.cursor() as cursor:
                cursor.executemany(sql, params_list, batcherrors=True)
                for error in cursor.getbatcherrors():
                    print(f"DB Error: {error.message} at row offset {error.offset}")
                connection.commit()

    def setup_tables(self):
        print("ğŸ” ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ ì„¤ì • ì‹œì‘...")
        
        # BUSINESS_INFO í…Œì´ë¸”
        try:
            business_sql = """
            CREATE TABLE business_info (
                id NUMBER(1) DEFAULT 1 NOT NULL,
                business_name NVARCHAR2(100) NOT NULL,
                blog_url VARCHAR2(1024),
                chatbot_personality NVARCHAR2(500),
                faqs NCLOB,
                marketing_info NCLOB,
                last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                CONSTRAINT business_info_pk PRIMARY KEY (id),
                CONSTRAINT single_row_check CHECK (id = 1)
            )
            """
            self._execute_sql(business_sql, commit=True)
            print("  - 'business_info' í…Œì´ë¸” ìƒì„± ì™„ë£Œ.")
        except oracledb.Error as e:
            if "ORA-00955" in str(e): 
                print("  - 'business_info' í…Œì´ë¸”ì´ ì´ë¯¸ ì¡´ì¬í•©ë‹ˆë‹¤.")
            else: 
                print(f"  - business_info í…Œì´ë¸” ìƒì„± ì˜¤ë¥˜: {e}")
                raise

        # POSTS í…Œì´ë¸”
        try:
            posts_sql = """
            CREATE TABLE posts (
                id NUMBER GENERATED BY DEFAULT AS IDENTITY,
                post_url VARCHAR2(1024) NOT NULL,
                title NVARCHAR2(512),
                content_hash VARCHAR2(64),
                crawled_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                CONSTRAINT posts_pk PRIMARY KEY (id),
                CONSTRAINT posts_url_uk UNIQUE (post_url)
            )
            """
            self._execute_sql(posts_sql, commit=True)
            print("  - 'posts' í…Œì´ë¸” ìƒì„± ì™„ë£Œ.")
        except oracledb.Error as e:
            if "ORA-00955" in str(e): 
                print("  - 'posts' í…Œì´ë¸”ì´ ì´ë¯¸ ì¡´ì¬í•©ë‹ˆë‹¤.")
            else: 
                print(f"  - posts í…Œì´ë¸” ìƒì„± ì˜¤ë¥˜: {e}")
                raise
        
        # CHUNKS í…Œì´ë¸” (FAISS ì¸ë±ìŠ¤ íŒŒì¼ ê²½ë¡œ ì €ì¥)
        try:
            chunks_sql = """
            CREATE TABLE chunks (
                id NUMBER GENERATED BY DEFAULT AS IDENTITY,
                post_id NUMBER NOT NULL,
                chunk_text NCLOB,
                chunk_vector NCLOB, -- Oracle AI Vector Searchë¥¼ ìœ„í•œ ë²¡í„° ì„ë² ë”© ì €ì¥ (ë¬¸ìì—´ë¡œ ì €ì¥)
                CONSTRAINT chunks_pk PRIMARY KEY (id),
                CONSTRAINT fk_post FOREIGN KEY (post_id) REFERENCES posts (id) ON DELETE CASCADE
            )
            """
            self._execute_sql(chunks_sql, commit=True)
            print("  - 'chunks' í…Œì´ë¸” ìƒì„± ì™„ë£Œ (FAISS ê²½ë¡œ ì €ì¥ìš©).")
        except oracledb.Error as e:
            if "ORA-00955" in str(e): 
                print("  - 'chunks' í…Œì´ë¸”ì´ ì´ë¯¸ ì¡´ì¬í•©ë‹ˆë‹¤.")
            else: 
                print(f"  - chunks í…Œì´ë¸” ìƒì„± ì˜¤ë¥˜: {e}")
                raise

        # QA_CACHE í…Œì´ë¸”
        try:
            cache_sql = """
            CREATE TABLE qa_cache (
                question_hash VARCHAR2(64),
                answer NCLOB NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                CONSTRAINT qa_cache_pk PRIMARY KEY (question_hash)
            )
            """
            self._execute_sql(cache_sql, commit=True)
            print("  - 'qa_cache' í…Œì´ë¸” ìƒì„± ì™„ë£Œ.")
        except oracledb.Error as e:
            if "ORA-00955" in str(e): 
                print("  - 'qa_cache' í…Œì´ë¸”ì´ ì´ë¯¸ ì¡´ì¬í•©ë‹ˆë‹¤.")
            else: 
                print(f"  - qa_cache í…Œì´ë¸” ìƒì„± ì˜¤ë¥˜: {e}")
                raise

        # USERS í…Œì´ë¸”
        try:
            users_sql = """
            CREATE TABLE users (
                id NUMBER GENERATED BY DEFAULT AS IDENTITY,
                username NVARCHAR2(50) NOT NULL UNIQUE,
                email NVARCHAR2(100) NOT NULL UNIQUE,
                password NVARCHAR2(255) NOT NULL,
                is_premium NUMBER(1,0) DEFAULT 0 NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                CONSTRAINT users_pk PRIMARY KEY (id)
            )
            """
            self._execute_sql(users_sql, commit=True)
            print("  - 'users' í…Œì´ë¸” ìƒì„± ì™„ë£Œ.")
        except oracledb.Error as e:
            if "ORA-00955" in str(e): 
                print("  - 'users' í…Œì´ë¸”ì´ ì´ë¯¸ ì¡´ì¬í•©ë‹ˆë‹¤.")
            else: 
                print(f"  - users í…Œì´ë¸” ìƒì„± ì˜¤ë¥˜: {e}")
                raise
                
        print("âœ… ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ ì„¤ì •ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.")

    def _drop_table_if_exists(self, table_name: str):
        try:
            self._execute_sql(f"DROP TABLE {table_name} CASCADE CONSTRAINTS", commit=True)
            print(f"  - '{table_name}' í…Œì´ë¸” ì‚­ì œ ì™„ë£Œ.")
        except oracledb.Error as e:
            if "ORA-00942" in str(e):
                print(f"  - '{table_name}' í…Œì´ë¸”ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.")
            else:
                print(f"  - '{table_name}' í…Œì´ë¸” ì‚­ì œ ì˜¤ë¥˜: {e}")
                raise

    def reset_database(self):
        print("ğŸš¨ ë°ì´í„°ë² ì´ìŠ¤ ì´ˆê¸°í™” ì‹œì‘...")
        # í…Œì´ë¸” ì‚­ì œ (ì˜ì¡´ì„± ì—­ìˆœìœ¼ë¡œ)
        self._drop_table_if_exists("qa_cache")
        self._drop_table_if_exists("chunks")
        self._drop_table_if_exists("posts")
        self._drop_table_if_exists("business_info")
        self._drop_table_if_exists("users")
        
        # í…Œì´ë¸” ë‹¤ì‹œ ìƒì„±
        self.setup_tables()
        print("âœ… ë°ì´í„°ë² ì´ìŠ¤ ì´ˆê¸°í™” ë° ì¬ì„¤ì • ì™„ë£Œ.")

    def get_user_by_id(self, user_id):
        with self._get_connection() as conn:
            with conn.cursor() as cur:
                cur.execute("SELECT id, username, email, password, NVL(is_premium, 0) FROM users WHERE id = :id", [user_id])
                row = cur.fetchone()
        
        if row:
            return {'id': row[0], 'username': row[1], 'email': row[2], 'password': row[3], 'is_premium': row[4]}
        return None

    def get_user_by_username(self, username):
        with self._get_connection() as conn:
            with conn.cursor() as cur:
                cur.execute("SELECT id, username, email, password, NVL(is_premium, 0) FROM users WHERE username = :username", [username])
                row = cur.fetchone()
        
        if row:
            return {'id': row[0], 'username': row[1], 'email': row[2], 'password': row[3], 'is_premium': row[4]}
        return None

    def create_user(self, username, email, hashed_password):
        with self._get_connection() as conn:
            with conn.cursor() as cur:
                cur.execute("INSERT INTO users (username, email, password, is_premium) VALUES (:username, :email, :password, 0)", [username, email, hashed_password])
                conn.commit()

    def upgrade_user_to_premium(self, user_id):
        with self._get_connection() as conn:
            with conn.cursor() as cur:
                cur.execute("UPDATE users SET is_premium=1 WHERE id=:id", [user_id])
                conn.commit()

    def get_post_hash(self, post_url: str) -> Optional[str]:
        sql = "SELECT content_hash FROM posts WHERE post_url = :url"
        result = self._execute_sql(sql, {'url': post_url})
        return result[0][0] if result and result[0][0] else None

    def upsert_post_with_chunks(self, post_url: str, title: str, content_hash: str, chunks_data: List[Dict[str, Any]]):
        # ê¸°ì¡´ ë°ì´í„° ì‚­ì œ
        delete_sql = """
        BEGIN 
            DELETE FROM chunks WHERE post_id IN (SELECT id FROM posts WHERE post_url = :url); 
            DELETE FROM posts WHERE post_url = :url; 
        END;
        """
        self._execute_sql(delete_sql, {'url': post_url}, commit=True)
        
        # ìƒˆ ê²Œì‹œê¸€ ì‚½ì…
        insert_post_sql = """
        INSERT INTO posts (post_url, title, content_hash) 
        VALUES (:post_url, :title, :hash) 
        RETURNING id INTO :post_id
        """
        with self.pool.acquire() as conn, conn.cursor() as cursor:
            post_id_var = cursor.var(oracledb.DB_TYPE_NUMBER)
            cursor.execute(insert_post_sql, {
                'post_url': post_url, 
                'title': title, 
                'hash': content_hash, 
                'post_id': post_id_var
            })
            post_id = post_id_var.getvalue()[0]
            conn.commit()
        # ì²­í¬ ë°ì´í„° ì €ì¥
        if chunks_data:
            insert_chunks_sql = """
            INSERT INTO chunks (post_id, chunk_text, chunk_vector) 
            VALUES (:post_id, :chunk_text, :chunk_vector)
            """
            with self.pool.acquire() as conn, conn.cursor() as cursor:
                for chunk in chunks_data:
                    params = {
                        'post_id': post_id, 
                        'chunk_text': chunk['chunk_text'], 
                        'chunk_vector': json.dumps(chunk['embedding'].tolist()) # JSON í˜•ì‹ìœ¼ë¡œ ì €ì¥
                    }
                    cursor.execute(insert_chunks_sql, params)
                conn.commit()
        
        print(f"  > ê²Œì‹œê¸€ '{title}' ë° {len(chunks_data)}ê°œ ì²­í¬ ì €ì¥ ì™„ë£Œ.")

    def get_cached_answer(self, question_hash: str) -> Optional[str]:
        sql = "SELECT answer FROM qa_cache WHERE question_hash = :hash"
        result = self._execute_sql(sql, {'hash': question_hash})
        return result[0][0] if result and result[0][0] else None
    
    def cache_answer(self, question_hash: str, answer: str):
        sql = "INSERT INTO qa_cache (question_hash, answer) VALUES (:hash, :answer)"
        self._execute_sql(sql, {'hash': question_hash, 'answer': answer}, commit=True)
        print("  - ìƒˆë¡œìš´ ë‹µë³€ì„ ìºì‹œì— ì €ì¥í–ˆìŠµë‹ˆë‹¤.")

    def save_business_info(self, info: Dict[str, Any]):
        sql = """
        MERGE INTO business_info dest 
        USING (SELECT 1 AS id FROM dual) src 
        ON (dest.id = src.id)
        WHEN MATCHED THEN 
            UPDATE SET 
                business_name = :name, 
                blog_url = :url, 
                chatbot_personality = :personality, 
                faqs = :faqs, 
                marketing_info = :marketing, 
                last_updated = CURRENT_TIMESTAMP
        WHEN NOT MATCHED THEN 
            INSERT (id, business_name, blog_url, chatbot_personality, faqs, marketing_info) 
            VALUES (1, :name, :url, :personality, :faqs, :marketing)
        """
        params = {
            'name': info['business_name'], 
            'url': info['blog_url'], 
            'personality': info['chatbot_personality'], 
            'faqs': json.dumps(info['faqs'], ensure_ascii=False), 
            'marketing': info['marketing_info']
        }
        self._execute_sql(sql, params, commit=True)
        print("âœ… ì—…ì²´ ì •ë³´ê°€ ë°ì´í„°ë² ì´ìŠ¤ì— ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.")

    def get_business_info(self) -> Optional[Dict[str, Any]]:
        sql = "SELECT business_name, blog_url, chatbot_personality, faqs, marketing_info FROM business_info WHERE id = 1"
        result = self._execute_sql(sql)
        if not result: 
            return None
        
        row = result[0]
        faqs_json = row[3] if row[3] else '[]'
        marketing_text = row[4] if row[4] else ''
        
        return {
            'business_name': row[0], 
            'blog_url': row[1], 
            'chatbot_personality': row[2], 
            'faqs': json.loads(faqs_json), 
            'marketing_info': marketing_text
        }

    def find_similar_chunks(self, query_vector: list, k: int = 5) -> List[Tuple[str, float]]:
        # ëª¨ë“  ì²­í¬ ë°ì´í„°ë¥¼ ê°€ì ¸ì™€ Pythonì—ì„œ ìœ ì‚¬ë„ ê³„ì‚°
        sql = "SELECT chunk_text, chunk_vector FROM chunks"
        results = self._execute_sql(sql)
        print(f"  - [Debug] chunks í…Œì´ë¸”ì—ì„œ {len(results) if results else 0}ê°œì˜ ì²­í¬ë¥¼ ê°€ì ¸ì™”ìŠµë‹ˆë‹¤.")

        query_np_vector = np.array(query_vector)
        similarities = []

        if results:
            for row in results:
                chunk_text = row[0] if hasattr(row[0], 'read') else row[0]
                chunk_vector_str = row[1] if hasattr(row[1], 'read') else row[1]
                
                try:
                    # ë¬¸ìì—´ í˜•íƒœì˜ ë²¡í„°ë¥¼ NumPy ë°°ì—´ë¡œ ë³€í™˜
                    chunk_np_vector = np.array(json.loads(chunk_vector_str))
                    
                    # L2 Distance (ìœ í´ë¦¬ë“œ ê±°ë¦¬) ê³„ì‚°
                    distance = np.linalg.norm(query_np_vector - chunk_np_vector)
                    similarities.append((chunk_text, distance))
                except json.JSONDecodeError as e:
                    print(f"âŒ ë²¡í„° ë¬¸ìì—´ íŒŒì‹± ì˜¤ë¥˜: {e} - {chunk_vector_str[:100]}...") # ì˜¤ë¥˜ë‚˜ëŠ” ë¬¸ìì—´ ì¼ë¶€ ì¶œë ¥
                    continue
                except Exception as e:
                    print(f"âŒ ìœ ì‚¬ë„ ê³„ì‚° ì¤‘ ì˜ˆê¸°ì¹˜ ì•Šì€ ì˜¤ë¥˜: {e}")
                    continue
        
        # ê±°ë¦¬ê°€ ì§§ì€ ìˆœì„œëŒ€ë¡œ ì •ë ¬í•˜ê³  ìƒìœ„ kê°œ ë°˜í™˜
        similarities.sort(key=lambda x: x[1])
        return similarities[:k]

    def close(self):
        if self.pool: 
            self.pool.close()
            print("ğŸ”Œ Oracle Cloud ATP ì—°ê²° í’€ì„ ë‹«ì•˜ìŠµë‹ˆë‹¤.")
